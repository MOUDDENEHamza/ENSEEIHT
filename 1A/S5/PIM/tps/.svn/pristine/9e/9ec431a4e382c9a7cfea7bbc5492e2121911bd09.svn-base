{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Langage C  (semestre 6)\n",
    "\n",
    "#### Katia Jaffrès-Runser, Xavier Crégut\n",
    "\n",
    "Toulouse INP - ENSEEIHT,\n",
    "\n",
    "1ère année, Dept. Sciences du Numérique, 2019-2020."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Déroulement du cours - Langage C\n",
    "---\n",
    "Ce cours est découpé en deux parties, la première ayant lieu au semestre 5, la seconde au semestre 6. \n",
    "\n",
    "- Au semestre 5, les acquis vous permettront de suivre les TPs du _cours d'automatisme_. Le cours de C en S5 est validé par une note inclue dans l'[UE Signal et Automatisme](http://moodle-n7.inp-toulouse.fr/course/index.php?categoryid=395). \n",
    "- Au semestre 6, les acquis vous permettront de suivre les TPs du cours de _systèmes d'exploitation_ mais aussi de _technologie objet_. Le cours de C en S6 est validé par une note inclue dans l'[UE Architecture et Systèmes](http://moodle-n7.inp-toulouse.fr/course/index.php?categoryid=400). \n",
    "\n",
    "A chaque semestre, vous suivrez 3 séances de TPs : \n",
    "\n",
    "- Lors de ces trois séances de TP, vous serez amenés à suivre un notebook Jupyter présentant des éléments de cours associés à un ensemble d'exemples et d'exercices à réaliser. La majorité des exercices peut être réalisée directement dans le Notebook. Ce travail se poursuit hors séance, en autonomie. Le notebook est archivé sous SVN mais n'est pas noté.\n",
    "\n",
    "Deux exercices bilan (Bilan 1 et Bilan 2) sont intégrés au notebook :\n",
    "- Bilan 1: Il est conseillé d'avoir suffisamment avancé dans la progression du Notebook pour que le Bilan 1 soit réalisé lors de la 2e séance de TP. Le bilan 1 n'est pas noté.\n",
    "- Bilan 2 : Les exercices du bilan 2 sont réalisés lors de la séance 3. Une partie des exercices du bilan 2 sera à rendre via SVN.\n",
    "\n",
    ">__Attention : tout travail est individuel__. Des outils de détection de recopie de code seront utilisés pour détecter la fraude. __Les étudiant ayant partagé leur travail seront également pénalisés.__\n",
    "\n",
    "La note finale est une moyenne des deux notes :\n",
    "- Un QCM de 30 minutes validera vos acquis en avril.\n",
    "- Les exercices du bilan 2 à rendre."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Objectifs \n",
    "Ce cours, sous la forme de notebooks Jupyter et d'un ensemble d'exercices à réaliser en TP, a pour objectif de vous présenter les spécificités de la programmation en langage C. Il se base sur vos acquis du cours de Programmation Impérative en algorithmique et vous détaille les éléments du langage C nécessaires à la production d'un programme en C. \n",
    "\n",
    "Un support de cours PDF vous est également fournit sur Moodle : [Cours C](http://moodle-n7.inp-toulouse.fr/pluginfile.php/49240/mod_resource/content/5/LangageC_poly.pdf)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###### Plan du contenu étudié au semestre 6. \n",
    "---\n",
    "\n",
    "Les éléments suivants de la programmation en Langage C sont présentés dans les 3 séances de TP au semestre 6.\n",
    "\n",
    "- L'allocation dynamique de mémoire\n",
    "- Les modules\n",
    "- L'automatisation de la compilation avec l'outil `make`\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Rappel : Jupyter notebook\n",
    "\n",
    "Le support de cours que vous lisez est un notebook Jupyter. Pour visualiser le notebook, lancer l'editeur web avec la commande  \n",
    "> `jupyter-notebook`\n",
    "\n",
    "et rechercher le fichier dans l'arborescence. Le fichier est édité dans votre navigateur Web par défaut. L'enregistrement est automatique (`CTRL S` pour le forcer). \n",
    "\n",
    "Pour fermer votre fichier, il faut fermer le navigateur et terminer le processus serveur qui s'exécute dans le terminal (`CTRL C`, puis `y`).\n",
    "\n",
    "> __Important__ : \n",
    "> - Pour faire fonctionner le kernel C de jupyter notebook, il faut, avant une __première utilisation__ de Notebook, lancer la commande suivante dans un `Terminal` : \n",
    "\n",
    "> `install_c_kernel --user`\n",
    "\n",
    "\n",
    "Ce notebook se compose de cellules présentant soit :\n",
    "- Des éléments de cours, au format [Markdown](https://fr.wikipedia.org/wiki/Markdown). Ce langage est traduit en HTML pour un affichage aisé quand on clique sur la flèche `Exécuter (run)` et que la cellule est active.\n",
    "- Du code en Langage C (ou Python, ou autre..). Pour compiler et exécuter le code écrit dans la cellule active, on clique sur la flèche `Exécuter (run)`. Si la compilation se déroule sans erreur ni avertissement, le programme est exécuté et les sorties sont affichées en bas de la cellule. Si ce n'est pas le cas, les avertissements et warnings sont affichés en bas de la cellule. \n",
    "\n",
    "En double-cliquant sur une cellule, on peut éditer son contenu. \n",
    "Vous pouvez ainsi : \n",
    "- Editer une cellule markdown pour y intégrer vos propres notes. \n",
    "- Modifier les programmes pour répondre aux questions et exercices proposés.\n",
    "\n",
    "Il est possible d'exporter votre travail en PDF, HTML, etc.\n",
    "\n",
    "Le programme dans la cellule suivante s'exécute sans erreur. Vous pouvez \n",
    "- le tester en l'exécutant. \n",
    "- y introduire une erreur (suppression d'un point-virgule par exemple) pour observer la sortie du compilateur.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <stdlib.h> \n",
    "#include <stdio.h>\n",
    "int main(){\n",
    "    printf(\"******************************\\n\");\n",
    "    printf(\"******** Langage C ***********\\n\");\n",
    "    printf(\"******************************\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Allocation dynamique de mémoire"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.1 Structure de la mémoire\n",
    "La mémoire vive de votre ordinateur est structurée en différentes parties : \n",
    "- __Le mémoire statique__\n",
    "Zone de la mémoire où sont stockées les données qui ont la même durée\n",
    "de vie que le programme (variables globales).\n",
    "- __La mémoire automatique__\n",
    "Zone de la mémoire appelée _pile d'exécution_ où sont stockés les blocs d'activation, paramètres et variables locales des sous-programmes. Cette mémoire est gérée automatiquement par le compilateur (réservation et libération). La mémoire est contigüe (sans trous).\n",
    "- __La mémoire dynamique__\n",
    "Zone de la mémoire aussi appelée _tas_ dans laquelle le programmeur peut explicitement réserver (allouer) de la place. Il devra la libérer explicitement. Cette zone est fragmentée (trous)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Utilisation de la mémoire dynamique\n",
    "\n",
    "L'enregistrement d'une donnée dans une zone de la mémoire dynamique nécessite une __demande d'allocation explicite__ de ladite zone. Cette zone mémoire est référencée à traver  __un pointeur__. Ainsi, l'écriture et la lecture de la donnée se fait exclusivement par ce pointeur.\n",
    "\n",
    "Quand la zone mémoire n'est plus utile, il faut __demander explicitement la libération__ de l'espace mémoire en C"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "### 4.2 Allocation de mémoire\n",
    "\n",
    "La bibliothèque `stdlib.h` (ou `malloc.h`) offre 3 procédures d'allocation de mémoire : `malloc`, `calloc` et `realloc`. Elle définit aussi une procédure de libération de mémoire `free`.\n",
    "\n",
    "#### L'allocateur `malloc`\n",
    "C'est l'allocateur utilisé le plus couramment :\n",
    "> `void* malloc(size_t taille);`\n",
    "\n",
    "Ici on trouve : \n",
    "- Le type de retour `void *` qui représente un type pointeur générique sur une zone mémoire. Le pointeur retourné vaut `NULL` si l'allocation échoue (manque d'espace mémoire contigüe).\n",
    "- Le type `size_t` qui est un alias de `unsigned int` et représente la __taille en octets__ de la zone mémoire réservée.\n",
    "\n",
    "#### L'opérateur `sizeof`\n",
    "- Pour obtenir la taille en octets d'une variable ou d'un type, on utilise la fonction `sizeof()` : \n",
    "> `sizeof(ma_variable)` ou `sizeof(type)`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Exemples d'allocations : \n",
    "```\n",
    "    char* un_char = malloc(sizeof(char));\n",
    "    char* autre_char = malloc(sizeof(*autre_char)); //taille du type pointé\n",
    "    \n",
    "    enum genre = {H, F, NC};\n",
    "    enum genre * il = malloc(sizeof(enum genre));\n",
    "```\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### L'allocateur `calloc`\n",
    "C'est une variante de Malloc : \n",
    "> `void* calloc(size_t nombre, size_t taille_element);`\n",
    "\n",
    "Ici, on trouve la taille de la zone mémoire allouée est décrite avec deux paramètres :\n",
    "- La taille d'un élément avec `taille_element`\n",
    "- Et le nombre d'éléments `nombre` de cette taille.\n",
    "On a alloue donc `nombre * taille_element` octets. \n",
    "\n",
    "> __Note :__ A la différence de malloc, tous les bits de la zone allouée sont positionnés à zéro."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Libérer la mémoire avec  `free` : \n",
    "Désallouer se fait avec la fonction : \n",
    "> `void free(void* pointeur);`\n",
    "\n",
    "L'unique paramètre est le pointeur qui désigne l'adresse de la mémoire à désallouer. \n",
    "> __Attention__ la libération ne modifie pas l'adresse enregistrée dans le pointeur. Il faut explicitement oublier l'adresse non-valide en initialisant le pointeur à `NULL` :\n",
    "\n",
    "```C\n",
    "    free(ptr_int);\n",
    "    ptr_int = NULL;\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Voici un exemple d'allocation, utilisation et libération de la mémoire :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Donnée enregistrée : 10\n"
     ]
    }
   ],
   "source": [
    "#include <stdio.h>\n",
    "#include <stdlib.h>\n",
    "#include <assert.h>\n",
    "\n",
    "void exemple_dynamique(){\n",
    "    //Allouer dynamiquement un entier\n",
    "    unsigned int taille = sizeof(int);\n",
    "    int *mon_entier = malloc(taille);\n",
    "    //Vérifier le succès de la demande d'allocation\n",
    "    assert(mon_entier != NULL);\n",
    "    \n",
    "    //Initialiser la donnée à travers le pointeur mon_entier\n",
    "    *mon_entier = 10;\n",
    "    //Accéder à la donnée\n",
    "    printf(\"Donnée enregistrée : %d\\n\", *mon_entier);\n",
    "    \n",
    "    //Libérer la mémoire dynamique\n",
    "    free(mon_entier);\n",
    "    //Oublier l'adresse mémoire\n",
    "    mon_entier = NULL;\n",
    "}\n",
    "\n",
    "int main() {\n",
    "    exemple_dynamique();\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On observe les éléments suivants : \n",
    "\n",
    "- L'allocation est ici réalisée avec la fonction `malloc(taille)` qui retourne un pointeur. Elle demande l'allocation de `taille` octets. \n",
    "Si l'allocation est réalisée avec succès, elle retourne l'adresse de la zone mémoire via le pointeur. Sinon, elle retourne `NULL`.\n",
    "\n",
    "- L'accès à la donnée est réalisé via le pointeur `mon_entier`\n",
    "\n",
    "- La libération de la mémoire utilise la fonction `free(mon_entier)`. \n",
    "\n",
    "> __Attention__ la libération ne modifie pas l'adresse enregistrée dans le pointeur. Il faut explicitement oublier l'adresse non-valide en initialisant le pointeur à `NULL`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.3 Allocation d'un tableau avec `malloc`\n",
    "Pour allouer un tableau de N éléments dynamiquement, il suffit de demander l'espace mémoire pour contenir les N éléments :  \n",
    "\n",
    "```\n",
    "    // Allocation d'un tableau de 10 entiers\n",
    "    int* mon_tableau = malloc(10*sizeof(int));\n",
    "```\n",
    "On peut alors utiliser la notation `mon_tableau[..]` pour accéder aux éléments du tableau.\n",
    "```\n",
    "    mon_tableau[0] = 20;\n",
    "```\n",
    "> __Attention__ : `sizeof(mon_tableau)` retourne uniquement la taille du pointeur `mon_tableau` alloué dynamiquement ! \n",
    "> Par contre, si un tableau est alloué statiquement, `sizeof` retourne la taille totale du tableau."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Exemple : `sizeof`, tableaux dynamiques et statiques."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Taille d'un entier : 4\n",
      "Taille d'un pointeur : 8\n",
      "Bravo ! Tous les tests passent.\n"
     ]
    }
   ],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "int main(){\n",
    "    int taille_entier = sizeof(int);\n",
    "    printf(\"Taille d'un entier : %d\\n\", taille_entier);\n",
    "    int taille_pointeur = sizeof(int*);\n",
    "    printf(\"Taille d'un pointeur : %d\\n\", taille_pointeur);\n",
    "    \n",
    "    // Allouer un tableau de 10 entiers\n",
    "    int* mon_tableau = malloc(10*taille_entier);\n",
    "    int taille_dynamique = sizeof(mon_tableau);\n",
    "    assert(taille_dynamique == taille_pointeur);\n",
    "    \n",
    "    // Declarer un tableau statique de 10 entiers \n",
    "    int mon_tab[10];\n",
    "    int taille_statique = sizeof(mon_tab);\n",
    "    assert(taille_statique == 10*taille_entier);\n",
    "    \n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Conséquence sur la définition d'un type tableau dynamique\n",
    "Il n'est pas possible d'utiliser `sizeof` pour connaitre la taille d'un tableau dynamique.\n",
    "\n",
    "> __Bonne pratique :__ Il convient donc d'enregistrer dans une variable la capacité actuelle du tableau à l'aide d'une enregistrement \n",
    "```\n",
    "    struct tab {\n",
    "        int* tableau; //Le tableau, alloué dynamiquement à l'initialisation\n",
    "        int capacite; //La capacité\n",
    "    };\n",
    "    typedef struct tab tab;\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1a : Manipuler les allocateurs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[C kernel] Executable exited with code -11"
     ]
    }
   ],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - compléter les instruction **** TODO **** \n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "\n",
    "    int* ptr_int; //un entier en mémoire dynamique \n",
    "    // **** TODO ****\n",
    "    // Allocation et initialisation à la valeur 100;\n",
    "\n",
    "\n",
    "    assert(*ptr_int == 100);\n",
    "\n",
    "        \n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!ptr_int);\n",
    "\n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1b : Manipuler les allocateurs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[C kernel] Executable exited with code -11"
     ]
    }
   ],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - compléter les instruction **** TODO **** \n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "\n",
    "\n",
    "    float* ptr_float; //un réel en mémoire dynamique \n",
    "    // **** TODO ****\n",
    "    // Allocation du réel avec CALLOC;\n",
    "\n",
    "    assert(*ptr_float == 0.0);\n",
    "\n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!ptr_float);\n",
    "        \n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1c : Manipuler les allocateurs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#define XXX 1\n",
    "\n",
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - Remplacer XXX par le bon résultat dans la suite.\n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "\n",
    "    enum chat {SIAMOIS, CALICO, PERSAN, TABBY};\n",
    "    enum chat * my_cat;\n",
    "    my_cat = calloc(1, sizeof(enum chat));\n",
    "    assert(*my_cat == XXX);\n",
    "\n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!my_cat);\n",
    "\n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 1.d : Manipuler les allocateurs\n",
    "Cet exercice utilise la bibliothèque [`string.h`](https://fr.wikipedia.org/wiki/String.h) qui offre des sous-programmes permettant de manipuler des chaines de caractère.\n",
    "\n",
    "Pour rappel, en C, une chaine de caratères est un tableau de caractères qui termine par le caractère `\\0`. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <string.h>\n",
    "\n",
    "// Consignes pour une obtenir une exécution sans erreur : \n",
    "//     - compléter les instruction **** TODO ****\n",
    "// Attention : toutes les variables sont ici allouées et libérées dynamiquent\n",
    "\n",
    "int main(){\n",
    "    char* chaine; //une chaine de caractère dynamique\n",
    "    // **** TODO ****\n",
    "    // Allocation pour pouvoir y copier la chaine constante \"LANGAGE_C\"\n",
    "    // à l'aide de la procédure strcpy() de string.h\n",
    "\n",
    "    strcpy(chaine, \"LANGAGE_C\");\n",
    "    assert(strcmp(chaine, \"LANGAGE_C\")==0);\n",
    "    assert(chaine[0] == 'L');\n",
    "    assert(chaine[9] == '\\0');\n",
    "    \n",
    "    //**** TODO **** \n",
    "    //Libérer toute la mémoire dynamique\n",
    "    \n",
    "    assert(!chaine);\n",
    "//---------\n",
    "        \n",
    "    printf(\"%s\", \"Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 2 : Allocation dynamique et statique d'un tableau.\n",
    "Dans l'exercice suivant, il faut compléter des sous-programmes permettant d'initialiser et manipuler les structures de données nécessaires à la réalisation d'une version simplifiée du jeu de UNO.\n",
    "\n",
    "Dans ce jeu, il y a 10 cartes de 4 couleurs différentes (jaune, rouge, vert et bleu), numérotées entre 0 et 9. Une main de 7 cartes est distribuée à 2 joueurs. Le premier joueur à avoir posé toutes ses cartes est le vainqueur. Une carte ne peut être posée que si elle présente le même numéro OU la même couleur que la précédente. Si un joueur ne peut poser une carte, il doit piocher une carte dans le tas de cartes restantes. \n",
    "\n",
    "Cet exercice a pour but de vous faire pratiquer la manipulation des tableaux dynamiques et statiques. Les consignes précises sont décrites dans le fichier ci-après. \n",
    "\n",
    "L'objectif de l'exercice est de réaliser une exécution sans erreur du programme de test proposé (`test_preparer_jeu_UNO`). Ce programme de test permet de vérifier la bonne préparation du jeu, et donc des étapes suivantes : \n",
    "- la création du jeu de 4*10 cartes, \n",
    "- la création de la main des deux joueurs. Chaque main comporte 7 cartes.\n",
    "- la création de la derniere carte posée pour démarrer le jeu."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[C kernel] Executable exited with code -6"
     ]
    }
   ],
   "source": [
    "#define XXX 1\n",
    "\n",
    "// Consignes : \n",
    "//  1. Remplacer XXX par le bon résultat dans la suite.\n",
    "//  2. Compléter avec les instructions nécessaires en lieu et place de \n",
    "//     **** TODO ****\n",
    "\n",
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <stdbool.h>\n",
    "#include <time.h>\n",
    "\n",
    "#define NB_VALEURS XXX\n",
    "#define NB_CARTES 4*NB_VALEURS\n",
    "\n",
    "//Définition du type enseigne\n",
    "enum couleur {JAUNE, ROUGE, VERT, BLEU};\n",
    "typedef enum couleur couleur;\n",
    "\n",
    "//Tableau de caractères représentant les couleurs\n",
    "char C[4] = {'J', 'R', 'V', 'B'};\n",
    "\n",
    "//Définition du type carte\n",
    "struct carte {\n",
    "    couleur couleur;\n",
    "    int valeur; //valeur >= 0 && valeur < NB_VALEURS\n",
    "    bool presente; // la carte est-elle presente dans le jeu ?\n",
    "};\n",
    "typedef struct carte carte;\n",
    "\n",
    "//Définition du type jeu complet pour enregistrer NB_CARTES cartes.\n",
    "typedef carte jeu[NB_CARTES];\n",
    "\n",
    "//Définition du type t_main, capable d'enregistrer un nombre variable de cartes.\n",
    "struct main {\n",
    "    carte * main; //tableau des cartes dans la main. \n",
    "    int nb; //monbre de cartes\n",
    "};\n",
    "typedef struct main t_main;\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une carte avec une couleur et une valeur. \n",
    " * \\param[in] c couleur de la carte\n",
    " * \\param[in] v valeur de la carte\n",
    " * \\param[in] ej booléen presente\n",
    " * \\param[out] la_carte \n",
    " */\n",
    "void init_carte(carte* la_carte, couleur c, int v, bool pr){\n",
    "    la_carte->couleur = c;\n",
    "    la_carte->valeur = v;\n",
    "    la_carte->presente = pr;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si la valeur de la carte est conforme à l'invariant.\n",
    " * \\param[in] c la carte\n",
    " * \\return bool vrai si la valeur est conforme, faux sinon.\n",
    " */\n",
    " bool est_conforme(carte c){\n",
    "    return (c.valeur>=0 && c.valeur<NB_VALEURS);\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une main.\n",
    " * \\param[in] N nombre de cartes composant la main.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] la_main créée\n",
    " * \\return true si l'initialisation a échouée.\n",
    " */\n",
    "bool init_main(t_main* la_main, int N){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "    // ***** TODO ***** \n",
    "    // Corriger l'initialisation du tableau main\n",
    "    la_main->main = NULL;\n",
    "    la_main->nb = N;\n",
    "    return (la_main==NULL); //allocation réussie ?\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser le jeu en ajoutant toutes les cartes possibles au jeu. \n",
    " * \\brief Chaque carte est alors présente dans le jeu.\n",
    " * \\param[out] le_jeu tableau de cartes avec les 4 couleurs et NB_VALEURS valeurs possibles\n",
    " */\n",
    "void init_jeu(jeu le_jeu){\n",
    "    int k=0;\n",
    "    for (int i=0 ; i<4 ; i++){\n",
    "        for (int j=0 ; j<NB_VALEURS ; j++){\n",
    "            init_carte(&(le_jeu[k]), i, j, true);\n",
    "            k++;\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Copie les valeurs de la carte src dans la carte dest.\n",
    " * \\param[in] src carte à copier\n",
    " * \\param[out] dest carte destination de la copie \n",
    " */\n",
    "void copier_carte(carte* dest, carte src){\n",
    "    dest->couleur = src.couleur;\n",
    "    dest->valeur = src.valeur;\n",
    "    dest->presente = src.presente;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une carte.\n",
    " * \\param[in] cte carte à afficher\n",
    " */\n",
    "void afficher_carte(carte cte){\n",
    "    printf(\"(%c;%d;%d)\\t\", C[cte.couleur], cte.valeur, cte.presente);\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Afficher le jeu.\n",
    " * \\param[in] le_jeu complet\n",
    " */\n",
    "void afficher_jeu(jeu le_jeu){\n",
    "    // ***** TODO ***** \n",
    "    // Afficher le jeu complet. Les carte sont listées sur une même ligne, \n",
    "    // et séparées par une tabulation \\t\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une main.\n",
    " * \\param[in] la_main la main a afficher\n",
    " */\n",
    "void afficher_main(t_main la_main){\n",
    "    // ***** TODO ***** \n",
    "    // Afficher le jeu complet. Les carte sont listées sur une même ligne, \n",
    "    // et séparées par une tabulation \\t\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief mélange le jeu.\n",
    " * \\param[in out] le_jeu complet mélangé\n",
    " */\n",
    "void melanger_jeu(jeu le_jeu){\n",
    "    for (int k=0; k<1000; k++){\n",
    "        // Choisir deux cartes aléatoirement\n",
    "        int i = rand()%NB_CARTES;\n",
    "        int j = rand()%NB_CARTES;        \n",
    "        // Les échanger\n",
    "        // ***** TODO **** \n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " \\brief Distribuer N cartes à chacun des deux joueurs, en alternant les joueurs.\n",
    " * \\param[in out] le_jeu complet.\n",
    " *       Si la carte c est distribuée dans une main, c.presente devient faux.\n",
    " * \\param[in] N nombre de cartes distribuées à chaque joueur.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] m1 main du joueur 1.\n",
    " * \\param[out] m2 main du joueur 2.\n",
    " */\n",
    "void distribuer_mains(jeu le_jeu, int N, t_main* m1, t_main* m2){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "\n",
    "    //Initialiser les mains de N cartes\n",
    "    bool errA = init_main(m1, N);\n",
    "    bool errB = init_main(m2, N);\n",
    "    assert(!errA && !errB);\n",
    "    \n",
    "    //Distribuer les cartes\n",
    "    for (int i=0; i<N; i++){\n",
    "        // ajout d'une carte dans la main m1\n",
    "        copier_carte(&(m1->main[i]), le_jeu[2*i]);\n",
    "        // ajout d'une carte dans la main m2\n",
    "        copier_carte(&(m2->main[i]), le_jeu[2*i+1]);\n",
    "        //mise à jour de presente à false dans le_jeu\n",
    "        le_jeu[2*i].presente = false;\n",
    "        le_jeu[2*i+1].presente = false;\n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialise le jeu de carte, les mains des joueurs et la carte 'last'.\n",
    " * \\param[out] le_jeu complet avec les 4 couleurs et 10 valeurs possibles.\n",
    " *                Ce jeu est mélangé.\n",
    " *                Si la carte est inclue dans une main ou est la derniere carte jouée,\n",
    " *                Alors carte.presente vaut faux.\n",
    " * \\param[in] N nombre de cartes par main.  Precondition : N <= (NB_CARTES-1)/2);\n",
    " * \\param[out] main_A main du joueur A.\n",
    " * \\param[out] main_B main du joueur B.\n",
    " * \\param[out] last la derniere carte jouée par un des joueurs.\n",
    " */\n",
    "int preparer_jeu_UNO(jeu le_jeu, int N, t_main* main_A, t_main* main_B, carte* last){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "    \n",
    "    //Initialiser le générateur de nombres aléatoires\n",
    "    time_t t;\n",
    "    srand((unsigned) time(&t));\n",
    " \n",
    "    //Initialiser le jeu\n",
    "    init_jeu(le_jeu);\n",
    "    \n",
    "    //Melanger le jeu\n",
    "    melanger_jeu(le_jeu);\n",
    "\n",
    "    //Distribuer N cartes à chaque joueur\n",
    "    distribuer_mains(le_jeu, N, main_A, main_B);\n",
    "\n",
    "    //Initialiser last avec la (2N+1)-ème carte du jeu.\n",
    "    copier_carte(last, le_jeu[2*N]);\n",
    "    le_jeu[2*N].presente = false; //carte n'est plus presente dans le_jeu\n",
    "    \n",
    "    return EXIT_SUCCESS;\n",
    "}\n",
    "\n",
    "void test_preparer_jeu_UNO(){\n",
    "    //Déclarer un jeu (tableau statique), les deux mains (tableaux dynamiques) et \n",
    "    //la carte last.\n",
    "    jeu le_jeu;\n",
    "    t_main main_A, main_B;\n",
    "    carte last;\n",
    " \n",
    "    //Préparer le jeu, les deux mains de 7 cartes et la carte last\n",
    "    int retour = preparer_jeu_UNO(le_jeu, 7, &main_A, &main_B, &last);\n",
    "    printf(\"\\n Le jeu mélangé avec les cartes presentes (c ; v ; p) : \\n\");\n",
    "    afficher_jeu(le_jeu);\n",
    "    printf(\"\\n Les deux mains : \\n\");\n",
    "    afficher_main(main_A);\n",
    "    afficher_main(main_B);\n",
    "    printf(\"\\n La carte last : \");\n",
    "    afficher_carte(last);\n",
    "    printf(\"\\n\");\n",
    "\n",
    "    //Vérifier le jeu et les mains.\n",
    "    assert(retour == EXIT_SUCCESS);\n",
    "    assert(main_A.nb == 7 && main_B.nb == 7);\n",
    "    assert(main_A.main != NULL && main_B.main != NULL);    \n",
    "    assert(est_conforme(main_A.main[0]));\n",
    "    assert(est_conforme(main_B.main[0]));\n",
    "    assert(est_conforme(last));\n",
    "        \n",
    "    //Détruire la mémoire allouée dynamiquement\n",
    "    // ***** TODO *****\n",
    "    \n",
    "    assert(main_A.main == NULL);\n",
    "    assert(main_B.main == NULL);\n",
    " \n",
    "}\n",
    "\n",
    "int main(void) {\n",
    "  \n",
    "    test_preparer_jeu_UNO();\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4.4 La réallocation avec `Realloc`\n",
    "En C, il est possible de réallouer une variable dynamique avec la procédure : \n",
    "> `void* realloc(void* ptr_mem, size_t taille)`\n",
    "\n",
    "Elle prend en paramètres : \n",
    "- le pointeur `ptr_mem` sur la zone mémoire dont on veut modifier la taille, \n",
    "- la nouvelle `taille` de la zone mémoire. \n",
    "\n",
    "Elle retroune : \n",
    "- un pointeur sur la zone mémoire allouée. __Si cette réallocation échoue, elle retoune `NULL`__. \n",
    "\n",
    "> __Note : __ La réallocation copie également les données enregistrées dans la zone mémoire initiale vers la nouvelle zone mémoire. \n",
    "\n",
    "On peut se servir de `realloc` pour : \n",
    "- Augmenter la taille mémoire allouée à l'origine.\n",
    "- Réduire la taille mémoire allouée à l'origine.\n",
    "- Libérer la mémoire. Dans ce cas, le paramètre `taille` vaut 0. Ce comportement est équivalement à `free`.\n",
    "- Allouer une nouvelle zone mémoire. Dans ce cas, le paramètre `ptr_mem` vaut `NULL`. Ce comportement est équivalent à `malloc`.\n",
    "\n",
    "Voici quelques exemples d'utilisation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Exemple d'une _mauvaise_ utilisation de `realloc`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "#define TAILLE 10\n",
    "\n",
    "int main(){\n",
    "\n",
    "    // Allouer un tableau de TAILLE entiers\n",
    "    int* tableau = malloc(TAILLE*sizeof(int));\n",
    "    assert(tableau); //allocation réussie ?\n",
    "    \n",
    "    // Initialiser les éléments à 1\n",
    "    for (int i=0; i<TAILLE; i++){\n",
    "        tableau[i]=1;\n",
    "    }\n",
    "    \n",
    "    // Augmenter la taille du tableau pour enregistrer TAILLE entiers supplémentaires.\n",
    "    tableau = realloc(tableau, (TAILLE+TAILLE)*sizeof(int));\n",
    "    assert(tableau); // ré-allocation réussie ?\n",
    "    \n",
    "    //test des 5 premiers éléments\n",
    "    assert(tableau[0]==1 && tableau[1]==1 && tableau[2]==1 && tableau[3]==1 && tableau[4]==1); \n",
    "\n",
    "    for (int i=TAILLE; i<TAILLE+TAILLE; i++){\n",
    "        tableau[i]=2;\n",
    "    }\n",
    "    \n",
    "    //test de 5 nouveaux éléments\n",
    "    assert(tableau[TAILLE]==2 && tableau[TAILLE+1]==2 && tableau[TAILLE+2]==2 && tableau[TAILLE+3]==2 && tableau[TAILLE+4]==2); \n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observation :__\n",
    "A posteriori, l'allocation et la réallocation se sont déroulées avec succès et les données présentes avant la réallocation sont toujours présentes après l'allocation. De plus, l'utilisation de l'espace supplémentaire se fait normalement. \n",
    "\n",
    "Dans l'exemple suivant, on vous propose d'augmenter la constante pré-processeur `INC` pour observer l'échec de la demande de réallocation. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      " Bravo ! Tous les tests passent.\n"
     ]
    }
   ],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "#define TAILLE 1000000\n",
    "#define INC 1e13\n",
    "\n",
    "int main(){\n",
    "\n",
    "    // Allouer un tableau de TAILLE entiers.\n",
    "    int* tableau = malloc(TAILLE*sizeof(int));\n",
    "    assert(tableau); //allocation réussie ?\n",
    "    \n",
    "    // Initialiser les éléments à 1\n",
    "    for (int i=0; i<TAILLE; i++){\n",
    "        tableau[i]=1;\n",
    "    }\n",
    "    \n",
    "    // Augmenter la taille du tableau pour enregistrer INC entiers supplémentaires.\n",
    "    tableau = realloc(tableau, (TAILLE+INC)*sizeof(int));\n",
    "    assert(tableau);\n",
    "    \n",
    "    // Initialiser l'élément d'indice 0 à 2\n",
    "    tableau[0]=2;\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observations : __\n",
    "\n",
    "- L'assertion de la ligne 21 n'est pas vérifiée quand `INC` devient trop grand : le pointeur tableau est donc `NULL`. \n",
    "\n",
    "- Si on commente l'instruction de la ligne 21, et que l'on ré-exécute le programme, on obtient une erreur `Executable exited with code -11`, ce qui correspond à un accès à une adresse mémoire non valide (i.e. un segmentation fault). L'adresse non valide est l'adresse `NULL` car à la ligne 24, on accède au premier élément du tableau.  \n",
    "__Ici, on a perdu l'accès aux données présentes dans le tableau d'origine avant réallocation !__\n",
    "\n",
    "> On observe ici __une double peine__ : \n",
    "> - La réallocation a échoué, \n",
    "> - Les données présentes dans le tableau avant `realloc` sont définitivement perdues. \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Exemple d'une _bonne_  utilisation de `realloc`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "\n",
    "#define TAILLE 1e6\n",
    "#define INC 1e14\n",
    "\n",
    "int main(){\n",
    "\n",
    "    // Allouer un tableau de TAILLE entiers initialisés à 1.\n",
    "    int* tableau = malloc(TAILLE*sizeof(int));\n",
    "    assert(tableau); //allocation réussie ?\n",
    "    \n",
    "    // Initialisation à 1\n",
    "    for (int i=0; i<TAILLE; i++){\n",
    "        tableau[i]=1;\n",
    "    }\n",
    "    \n",
    "    // Augmentater la taille du tableau pour enregistrer 10 entiers.\n",
    "    int* nouveau = realloc(tableau, (TAILLE+INC)*sizeof(int));\n",
    "    if (nouveau) {\n",
    "        //recopie de l'adresse uniquement si succès \n",
    "        tableau = nouveau;\n",
    "    }\n",
    "    assert(tableau[0]==1);\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice 3 : Reallocation et jeu de Uno.\n",
    "Toujour dans le jeu de Uno, on cherche à tester la procédure qui permet de piocher une carte parmi les cartes qui ne sont pas en jeu. \n",
    "Une carte est en jeu si elle appartient à une des deux mains, ou si elle est la dernière jouée.\n",
    "\n",
    "Dans le tableau statique `le_jeu` qui contient toutes les cartes du jeu, on référence une carte comme 'présente' si elle n'est pas en jeu. Quand on pioche, on cherche la première carte présente dans `le_jeu` et on l'ajoute à la main courante. La carte piochée du tableau `le_jeu` y est indiquée comme non-présente.\n",
    "\n",
    "L'objet de cet exercice est d'exécuter les tests de la procédure `carte * piocher(jeu le_jeu, t_main* main)` qui : \n",
    "- retourne un pointeur sur la carte piochée dans le jeu \n",
    "- null si elle aucune carte ne peut être piochée ou si la réallocation de mémoire échoue.\n",
    "\n",
    "L'essentiel du travail est à réaliser au niveau de cette procédure `piocher`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      " Les deux mains : \n",
      "(B;0;1)\t(J;2;1)\t(J;4;1)\t(J;6;1)\t(J;8;1)\t(R;0;1)\t(R;2;1)\t\n",
      "(J;1;1)\t(J;3;1)\t(J;5;1)\t(J;7;1)\t(J;9;1)\t(R;1;1)\t(R;3;1)\t\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "tmpnjw6v8nq.out: /tmp/tmp08laqox0.c:288: test_piocher: Assertion `c_piochee->presente==false' failed.\n",
      "[C kernel] Executable exited with code -6"
     ]
    }
   ],
   "source": [
    "\n",
    "// Consignes : \n",
    "//  1. Compléter avec les instructions requises en lieu et place de *** TODO ***\n",
    "\n",
    "#include <assert.h>\n",
    "#include <stdlib.h>\n",
    "#include <stdio.h>\n",
    "#include <stdbool.h>\n",
    "#include <time.h>\n",
    "\n",
    "#define NB_VALEURS 10\n",
    "#define NB_CARTES 4*NB_VALEURS\n",
    "\n",
    "//Définition du type enseigne\n",
    "enum couleur {JAUNE, ROUGE, VERT, BLEU};\n",
    "typedef enum couleur couleur;\n",
    "\n",
    "//Tableau de caractères représentant les couleurs\n",
    "char C[4] = {'J', 'R', 'V', 'B'};\n",
    "\n",
    "//Définition du type carte\n",
    "struct carte {\n",
    "    couleur couleur;\n",
    "    int valeur; // Invariant : valeur >= 0 && valeur < NB_VALEURS\n",
    "    bool presente; // la carte est-elle presente dans le jeu ?\n",
    "};\n",
    "typedef struct carte carte;\n",
    "\n",
    "//Définition du type jeu complet pour enregistrer NB_CARTES cartes.\n",
    "typedef carte jeu[NB_CARTES];\n",
    "\n",
    "//Définition du type t_main, capable d'enregistrer un nombre variable de cartes.\n",
    "struct main {\n",
    "    carte * main; //tableau des cartes dans la main. \n",
    "    int nb; //monbre de cartes\n",
    "};\n",
    "typedef struct main t_main;\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une carte avec une couleur et une valeur. \n",
    " * \\param[in] c couleur de la carte\n",
    " * \\param[in] v valeur de la carte\n",
    " * \\param[in] ej booléen presente\n",
    " * \\param[out] la_carte \n",
    " */\n",
    "void init_carte(carte* la_carte, couleur c, int v, bool pr){\n",
    "    la_carte->couleur = c;\n",
    "    la_carte->valeur = v;\n",
    "    la_carte->presente = pr;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si la valeur de la carte est conforme à l'invariant.\n",
    " * \\param[in] c la carte\n",
    " * \\return bool vrai si la valeur est conforme, faux sinon.\n",
    " */\n",
    " bool est_conforme(carte c){\n",
    "    return (c.valeur>=0 && c.valeur<NB_VALEURS);\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Copie les valeurs de la carte src dans la carte dest.\n",
    " * \\param[in] src carte à copier\n",
    " * \\param[out] dest carte destination de la copie \n",
    " */\n",
    "void copier_carte(carte* dest, carte src){\n",
    "    dest->couleur = src.couleur;\n",
    "    dest->valeur = src.valeur;\n",
    "    dest->presente = src.presente;\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une carte.\n",
    " * \\param[in] cte carte à afficher\n",
    " */\n",
    "void afficher_carte(carte cte){\n",
    "    printf(\"(%c;%d;%d)\\t\", C[cte.couleur],cte.valeur, cte.presente);\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser une main.\n",
    " * \\param[in] N nombre de cartes composant la main.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] la_main créée\n",
    " * \\return true si l'initialisation a échouée.\n",
    " */\n",
    "bool init_main(t_main* la_main, int N){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "    la_main->main = malloc(N*sizeof(carte));\n",
    "    la_main->nb = N;\n",
    "    return (la_main==NULL); //allocation réussie ?\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialiser le jeu en ajoutant toutes les cartes possibles au jeu.\n",
    " * \\param[out] le_jeu tableau de cartes avec les 4 couleurs et NB_VALEURS valeurs possibles\n",
    " */\n",
    "void init_jeu(jeu le_jeu){\n",
    "    int k=0;\n",
    "    for (int i=0 ; i<4 ; i++){\n",
    "        for (int j=0 ; j<NB_VALEURS ; j++){\n",
    "            init_carte(&(le_jeu[k]), i, j, true);\n",
    "            k++;\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher le jeu.\n",
    " * \\param[in] le_jeu complet avec les 4 couleurs et 910valeurs possibles\n",
    " */\n",
    "void afficher_jeu(jeu le_jeu){\n",
    "    for (int k=0; k<NB_CARTES; k++){\n",
    "        afficher_carte(le_jeu[k]);\n",
    "    }\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Afficher une main.\n",
    " * \\param[in] la_main la main a afficher\n",
    " */\n",
    "void afficher_main(t_main la_main){\n",
    "    for (int k=0; k<la_main.nb; k++){\n",
    "        afficher_carte(la_main.main[k]);\n",
    "    }\n",
    "    printf(\"\\n\");\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief mélange le jeu.\n",
    " * \\param[in out] le_jeu complet\n",
    " */\n",
    "void melanger_jeu(jeu le_jeu){\n",
    "    for (int i=0; i<1000; i++){\n",
    "        // Choisir deux cartes aléatoirement\n",
    "        int i = rand()%NB_CARTES;\n",
    "        int j = rand()%NB_CARTES;        \n",
    "        // Les échanger\n",
    "        carte mem;\n",
    "        copier_carte(&mem, le_jeu[i]); \n",
    "        copier_carte(&(le_jeu[i]), le_jeu[j]); \n",
    "        copier_carte(&(le_jeu[j]), mem); \n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " \\brief Distribuer N cartes à chacun des deux joueurs, en alternant les joueurs.\n",
    " * \\param[in out] le_jeu complet.\n",
    " *       Si la carte c est distribuée dans une main, c.presente devient faux.\n",
    " * \\param[in] N nombre de cartes distribuées à chaque joueur.  Précondition : N <= (NB_CARTES - 1) div 2\n",
    " * \\param[out] m1 main du joueur 1.\n",
    " * \\param[out] m2 main du joueur 2.\n",
    " */\n",
    "void distribuer_mains(jeu le_jeu, int N, t_main* m1, t_main* m2){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "\n",
    "    //Initialiser les mains de N cartes\n",
    "    bool errA = init_main(m1, N);\n",
    "    bool errB = init_main(m2, N);\n",
    "    assert(!errA && !errB);\n",
    "    \n",
    "    //Distribuer les cartes\n",
    "    for (int i=0; i<N; i++){\n",
    "        // ajout d'une carte dans la main m1\n",
    "        copier_carte(&(m1->main[i]), le_jeu[2*i]);\n",
    "        // ajout d'une carte dans la main m2\n",
    "        copier_carte(&(m2->main[i]), le_jeu[2*i+1]);\n",
    "        //mise à jour de presente à false dans le_jeu\n",
    "        le_jeu[2*i].presente = false;\n",
    "        le_jeu[2*i+1].presente = false;\n",
    "    }\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si les cartes c1 et c2 on la même couleur et la même valeur.\n",
    " * \\param[in] c1 carte\n",
    " * \\param[in] c2 carte\n",
    " * \\return bool Vrai si les deux cartes ont même valeur et couleur.\n",
    "*/\n",
    "bool est_egale(carte c1, carte c2){\n",
    "    return ((c1.couleur == c2.couleur) && (c1.valeur == c2.valeur));\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Vérifie si la carte c est présente dans la main.\n",
    " * \\param[in] main main d'un joueur\n",
    " * \\param[in] c carte\n",
    " * \\return bool Vrai si la carte est presente dans la main, faux sinon.\n",
    "*/\n",
    "bool est_presente_main(t_main main, carte c){\n",
    "    int i = 0;\n",
    "    while (i < main.nb && !est_egale(main.main[i], c)) {\n",
    "        i++;\n",
    "    }\n",
    "    return !(i == main.nb);\n",
    "}\n",
    "\n",
    "\n",
    "/**\n",
    " * \\brief Piocher une carte dans le jeu et l'inclure dans la main en paramètre.\n",
    " * \\param[in out] le_jeu complet avec les 4 couleurs et 10 valeurs possibles.\n",
    " *                Ce jeu est mélangé.\n",
    " *                Si la carte est inclue dans une main ou est la derniere carte jouée,\n",
    " *                Alors carte.presente vaut faux.\n",
    " * \\param[in out] main main d'un joueur\n",
    " * \\return carte * un pointeur sur la carte piochee dans le_jeu en paramètre. \n",
    " * Ce pointeur vaut NULL si aucune carte ne peut être piochée ou si l'allocation de mémoire échoue.\n",
    "*/\n",
    "carte * piocher(jeu le_jeu, t_main* main){\n",
    "    // Recherche une carte presente dans le jeu.\n",
    "    carte *carte_piochee = le_jeu;\n",
    "    int i = 0;\n",
    "    while(i < NB_CARTES && carte_piochee->presente == false){\n",
    "        carte_piochee = carte_piochee + 1;\n",
    "        i++;\n",
    "    }\n",
    "    if (i == NB_CARTES) {\n",
    "        carte_piochee = NULL;\n",
    "    } else {\n",
    "        // Inserer la carte dans la main       \n",
    "        //*** TODO *** ;\n",
    "        // Reallouer la mémoire pour enregistrer une carte de plus dans la main.\n",
    "        // Penser à l'echec de la reallocation\n",
    "        \n",
    "        // Copier la carte_piochee dans la main\n",
    "        \n",
    "        // Indiquer que carte_piochee n'est plus presente dans le_jeu\n",
    "        \n",
    "    }\n",
    "    return carte_piochee;\n",
    "}\n",
    "\n",
    "/**\n",
    " * \\brief Initialise le jeu de carte, les mains des joueurs et la carte 'last'.\n",
    " * \\param[out] le_jeu complet avec les 4 couleurs et 10 valeurs possibles.\n",
    " *                Ce jeu est mélangé.\n",
    " *                Si la carte est inclue dans une main ou est la derniere carte jouée,\n",
    " *                Alors carte.presente vaut faux.\n",
    " * \\param[in] N nombre de cartes par main.  Precondition : N <= (NB_CARTES-1)/2);\n",
    " * \\param[out] main_A main du joueur A.\n",
    " * \\param[out] main_B main du joueur B.\n",
    " * \\param[out] last la derniere carte jouée par un des joueurs.\n",
    " */\n",
    "int preparer_jeu_UNO(jeu le_jeu, int N, t_main* main_A, t_main* main_B, carte* last){\n",
    "    assert(N <= (NB_CARTES-1)/2);\n",
    "\n",
    "    //Initialiser le générateur de nombres aléatoires\n",
    "    time_t t;\n",
    "    srand((unsigned) time(&t));\n",
    " \n",
    "    //Initialiser le jeu\n",
    "    init_jeu(le_jeu);\n",
    "    \n",
    "    //Melanger le jeu\n",
    "    melanger_jeu(le_jeu);\n",
    "\n",
    "    //Distribuer N cartes à chaque joueur\n",
    "    distribuer_mains(le_jeu, N, main_A, main_B);\n",
    "\n",
    "    //Initialiser last avec la (2N+1)-ème carte du jeu.\n",
    "    copier_carte(last, le_jeu[2*N]);\n",
    "    le_jeu[2*N].presente = false; //carte n'est plus presente dans le_jeu\n",
    "\n",
    "    return EXIT_SUCCESS;\n",
    "}\n",
    "\n",
    "void test_piocher(){\n",
    "    jeu le_jeu; // le jeu de cartes\n",
    "    t_main main_A, main_B; // les deux mains\n",
    "    carte last; // la derniere carte posee\n",
    "   \n",
    "    //Préparer le jeu, les deux mains de 7 cartes et la carte last\n",
    "    int retour = preparer_jeu_UNO(le_jeu, 7, &main_A, &main_B, &last);\n",
    "    printf(\"\\n Les deux mains : \\n\");\n",
    "    afficher_main(main_A);\n",
    "    afficher_main(main_B);\n",
    "\n",
    "    int mem_taille = main_A.nb;\n",
    "    \n",
    "    //Le joueur A pioche une carte dans le_jeu\n",
    "    carte *c_piochee = piocher(le_jeu, &main_A);\n",
    "    \n",
    "    // Une carte a-t-elle été piochée ?\n",
    "    assert(c_piochee);\n",
    "    assert(c_piochee->presente==false); // absence du jeu ?\n",
    "    assert(est_presente_main(main_A, *c_piochee));\n",
    "    assert(main_A.nb = mem_taille + 1);\n",
    "\n",
    "    // Affichage\n",
    "    printf(\"\\n\\n ***** APRES la pioche : \");\n",
    "    printf(\"\\n La carte piochee : \");\n",
    "    afficher_carte(*c_piochee);\n",
    "    printf(\"\\n La nouvelle main A après pioche : \\n\");\n",
    "    afficher_main(main_A);\n",
    "    printf(\"\\n Le nouveau jeu après pioche : \\n\");\n",
    "    afficher_jeu(le_jeu);\n",
    "\n",
    "    //Détruire la mémoire allouée dynamiquement\n",
    "    free(main_A.main);\n",
    "    free(main_B.main);\n",
    "    main_A.main = NULL;\n",
    "    main_B.main = NULL;\n",
    "}\n",
    "\n",
    "int main(void) {\n",
    "  \n",
    "    test_piocher();\n",
    "    \n",
    "    printf(\"%s\", \"\\n Bravo ! Tous les tests passent.\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}\n"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Format de la Cellule Texte Brut",
  "kernelspec": {
   "display_name": "C",
   "language": "c",
   "name": "c"
  },
  "language_info": {
   "file_extension": ".c",
   "mimetype": "text/plain",
   "name": "c"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
