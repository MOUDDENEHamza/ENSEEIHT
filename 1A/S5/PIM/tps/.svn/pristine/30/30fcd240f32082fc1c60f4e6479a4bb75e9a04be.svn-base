{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> # Langage C (semestre 6)\n",
    "> ## TP2 : les modules en C.\n",
    "> #### Katia Jaffrès-Runser, Xavier Crégut\n",
    "> Toulouse INP - ENSEEIHT,\n",
    "> 1ère année, Dept. Sciences du Numérique, 2019-2020."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ++++ ATTENTION : Changements des modalités d'évaluation +++++ \n",
    "Contrairement à ce qui a été annoncé dans le sujet du TP1, et pour ne pas pénaliser les étudiants qui ont des difficultés à réaliser les exercices à distance, la suite du cours présente les modifications suivantes : \n",
    "> - Le Bilan 2 __ne sera pas évalué__. Les étudiants qui souhaitent obtenir une correction de leur travail du Bilan 2 (rendu via SVN), pourront demander une correction à leur intervenant. Des instructions seront disponibles sous Moodle à ce sujet.  \n",
    "> - Nous organiserons, dans les prochaines semaines (et de préférence quand nous serons de retour dans les locaux de l'N7), un QCM pour évaluer vos acquis. Ce test constituera la note de la matière. \n",
    "> - Les exercices présents dans les sujets TP2, TP3 et le Bilan 2 __ne nécessitent pas Jupyter Notebook__. Vous travaillerez uniquement sur les fichiers C présents dans le répertoire SVN `c2`, soit à distance sur les machines du centre informatique, soit directement sur votre machine avec un compilateur C. Les notebooks TP2 et Bilan 2 sont pour cela également disponibles au format HTML. \n",
    "> - Le travail décrit dans les notebooks TP2, TP3 et Bilan 2 sont à réaliser pendant les deux séances restantes. Nous vous fourniront un exercice supplémentaire la semaine prochaine, optionnel, qui vous permettra d'aller plus loin si vous le désirez."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Déroulement du cours - Langage C\n",
    "---\n",
    "Ce cours est découpé en deux parties, la première ayant lieu au semestre 5, la seconde au semestre 6. \n",
    "\n",
    "- Au semestre 5, les acquis vous permettront de suivre les TPs du _cours d'automatisme_. Le cours de C en S5 est validé par une note inclue dans l'[UE Signal et Automatisme](http://moodle-n7.inp-toulouse.fr/course/index.php?categoryid=395). \n",
    "- Au semestre 6, les acquis vous permettront de suivre les TPs du cours de _systèmes d'exploitation_ mais aussi de _technologie objet_. Le cours de C en S6 est validé par une note inclue dans l'[UE Architecture et Systèmes](http://moodle-n7.inp-toulouse.fr/course/index.php?categoryid=400). \n",
    "\n",
    "A chaque semestre, vous suivrez 3 séances de TPs : \n",
    "\n",
    "- Lors de ces trois séances de TP, vous serez amenés à suivre un notebook Jupyter présentant des éléments de cours associés à un ensemble d'exemples et d'exercices à réaliser. La majorité des exercices peut être réalisée directement dans le Notebook. Ce travail se poursuit hors séance, en autonomie. Le notebook est archivé sous SVN mais n'est pas noté.\n",
    "\n",
    "<!--Deux exercices bilan (Bilan 1 et Bilan 2) sont intégrés aux notebook :\n",
    "- Bilan 1: Il est conseillé d'avoir suffisamment avancé dans la progression du Notebook pour que le Bilan 1 soit réalisé lors de la 2e séance de TP. Le bilan 1 n'est pas noté.\n",
    "- Bilan 2 : Les exercices du bilan 2 sont réalisés lors de la séance 3. -->\n",
    "\n",
    "\n",
    "<!--__Attention : tout travail est individuel__. Des outils de détection de recopie de code seront utilisés pour détecter la fraude. __Les étudiant ayant partagé leur travail seront également pénalisés.__ -->\n",
    "\n",
    "<!-- La note finale est une moyenne des deux notes :\n",
    "- Un QCM de 30 minutes validera vos acquis.\n",
    "- Les exercices du bilan 2 à rendre. -->"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Objectifs \n",
    "Ce cours, sous la forme de notebooks Jupyter et d'un ensemble d'exercices à réaliser en TP, a pour objectif de vous présenter les spécificités de la programmation en langage C. Il se base sur vos acquis du cours de Programmation Impérative en algorithmique et vous détaille les éléments du langage C nécessaires à la production d'un programme en C. \n",
    "\n",
    "Un support de cours PDF vous est également fournit sur Moodle : [Cours C](http://moodle-n7.inp-toulouse.fr/pluginfile.php/49240/mod_resource/content/5/LangageC_poly.pdf)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###### Plan du contenu étudié au semestre 6. \n",
    "---\n",
    "\n",
    "Les éléments suivants de la programmation en Langage C sont présentés dans les 3 séances de TP au semestre 6.\n",
    "\n",
    "- L'allocation dynamique de mémoire (TP1)\n",
    "- Les modules (TP2)\n",
    "- L'automatisation de la compilation avec l'outil `make` (TP3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Rappel : Jupyter notebook\n",
    "\n",
    "Le support de cours que vous lisez est un notebook Jupyter. Pour visualiser le notebook, lancer l'editeur web avec la commande  \n",
    "> `jupyter-notebook`\n",
    "\n",
    "et rechercher le fichier dans l'arborescence. Le fichier est édité dans votre navigateur Web par défaut. L'enregistrement est automatique (`CTRL S` pour le forcer). \n",
    "\n",
    "Pour fermer votre fichier, il faut fermer le navigateur et terminer le processus serveur qui s'exécute dans le terminal (`CTRL C`, puis `y`).\n",
    "\n",
    "> __Important__ : \n",
    "> - Pour faire fonctionner le kernel C de jupyter notebook, il faut, avant une __première utilisation__ de Notebook, lancer la commande suivante dans un `Terminal` : \n",
    "\n",
    "> `install_c_kernel --user`\n",
    "\n",
    "Ce notebook se compose de cellules présentant soit :\n",
    "- Des éléments de cours, au format [Markdown](https://fr.wikipedia.org/wiki/Markdown). Ce langage est traduit en HTML pour un affichage aisé quand on clique sur la flèche `Exécuter (run)` et que la cellule est active.\n",
    "- Du code en Langage C (ou Python, ou autre..). Pour compiler et exécuter le code écrit dans la cellule active, on clique sur la flèche `Exécuter (run)`. Si la compilation se déroule sans erreur ni avertissement, le programme est exécuté et les sorties sont affichées en bas de la cellule. Si ce n'est pas le cas, les avertissements et warnings sont affichés en bas de la cellule. \n",
    "\n",
    "En double-cliquant sur une cellule, on peut éditer son contenu. \n",
    "Vous pouvez ainsi : \n",
    "- Editer une cellule markdown pour y intégrer vos propres notes. \n",
    "- Modifier les programmes pour répondre aux questions et exercices proposés.\n",
    "\n",
    "Il est possible d'exporter votre travail en PDF, HTML, etc.\n",
    "\n",
    "Le programme dans la cellule suivante s'exécute sans erreur. Vous pouvez \n",
    "- le tester en l'exécutant. \n",
    "- y introduire une erreur (suppression d'un point-virgule par exemple) pour observer la sortie du compilateur.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <stdlib.h> \n",
    "#include <stdio.h>\n",
    "int main(){\n",
    "    printf(\"******************************\\n\");\n",
    "    printf(\"******** Langage C ***********\\n\");\n",
    "    printf(\"******************************\\n\");\n",
    "    return EXIT_SUCCESS;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Les modules"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.1 Rappels : les modules en algorithmique\n",
    "\n",
    "#### Définition d'un module\n",
    "C'est une partie d'un programme définissant une __unité structurelle et fonctionnelle__.  \n",
    "Un module regroupe :\n",
    "- Un ensemble de déclarations, de constantes, de types, d'attributs et de sous-programmes  \n",
    "- L'ensemble des implantations (corps) de ces sous-programmes satisfaisant au principe de séparation.\n",
    "\n",
    "#### Structure d'un module\n",
    "Un module se compose : \n",
    "- d'une __interface (ou spécification)__ qui permet de déclarer les constantes, types, attributs au module et de spécifier les sous-programmes.  \n",
    "- d'un __corps (ou définition)__ où on regroupe l'implantation des différents sous-programmes spécifiés dans l'interface. Et éventuellement d'autres constantes, types, attributs et sous-programmes internes au module. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.2 Les modules en C  \n",
    ">> => n'existent pas à proprement parler !!!  \n",
    "> En effet, le langage C n'offre pas de _support syntaxique_ à la définition des modules. \n",
    "\n",
    "Le principe est le suivant. Un fichier C est :\n",
    "- Soit un programme principal avec un (et un seul) programme principal `int main()`;\n",
    "- Soit un `module` \n",
    "\n",
    "Un module en C, c'est :\n",
    "- Une convention de nommage qui décompose un module en deux fichiers, l'en-tête `.h` et le corps `.c`.  \n",
    "Par exemple, le module `complexe` se compose :\n",
    "> - d'un fichier d'interface typiquement nommé `complexe.h`\n",
    "> - d'un fichier corps typiquement nommé `complexe.c`\n",
    "- Un outillage pour compiler cette structure de fichiers :\n",
    "> - Comme le compilateur C ne sait travailler que sur un unique fichier qui regroupe interface et corps, il faut __inclure l'interface `complexe.h` au début du corps `complexe.c`__ à l'aide de la commande pré-processeur `#include \"complexe.h\"`.\n",
    "> - __Pour utiliser un module `complexe` dans un programme principal__ (`calculer.c` par exemple), on inclut son interface `complexe.h` au début du fichier avec la commande   \n",
    "```#include \"complexe.h\"```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Note__ : la commande `#include` indique le nom du module à inclure de deux façons différentes. \n",
    "- Soit entre `< >` comme pour `#include <stdlib.h>`. \n",
    "- Soit entre guillements, comme pour `#include \"complexe.h\"`.\n",
    "\n",
    "Dans le premier cas, le module est recherché par le pré-processeur dans des répertoires systèmes pré-définis.  \n",
    "Dans le second cas, le module est recherché dans le répertoire courant. \n",
    "Il est possible d'indiquer le chemin relatif ou absolu du fichier d'en-tête si on le souhaite :  \n",
    "`#include \"libs/complexe.h\"` recherche le fichier d'en-tête dans le répertoire `libs` du répertoire courant. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Interface ou fichier d'en-tête (`.h`)\n",
    "Pour expliciter ce que fournit le module, on décrit dans l'interface :  \n",
    "- la spécification avec la __déclaration en avant__ des sous-programmes, \n",
    "- la déclaration des éventuels types, constantes (et variables globales).\n",
    "\n",
    "#### Corps ou définition (`.c`)\n",
    "Le corps du module comporte :\n",
    "- l'inclusion de l'interface `#include \"module.h\"`\n",
    "- la définition des sous-programmes déclarés en avant dans le fichier d'en-tête,\n",
    "- la déclaration d'éventuels types, constantes (et variables globales),\n",
    "- la spécification et définition des sous-programmes __internes__ au modules. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.3 Exemple : module `date`\n",
    "\n",
    "Voici l'exemple des deux fichiers composant l'en-tête et le corps du module `date`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "____\n",
    "##### L'en-tête `date.h`:\n",
    "____\n",
    "```c\n",
    "/**\n",
    " *  module date\n",
    " */\n",
    "\n",
    "// Inclusion des bibliothèques nécessaires à l'interface __ET__ au corps\n",
    "#include <time.h>\n",
    "\n",
    "// Declaration des types \n",
    "enum NomJour { DIMANCHE, LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI};\n",
    "enum Mois {JAN, FEV, MAR, AVR, MAI, JUIN, JUIL, AOUT, SEPT, OCT, NOV, DEC };\n",
    "typedef enum NomJour NomJour;\n",
    "typedef enum Mois Mois;\n",
    "\n",
    "struct Date {\n",
    "    int jour;\n",
    "    NomJour nomJour;\n",
    "    Mois mois;\n",
    "    int annee;\n",
    "    // Invariant : jour>=1 && jour<=31; annee>0\n",
    "};\n",
    "typedef struct Date Date;\n",
    "\n",
    "\n",
    "// Declaration (en avant !) des fonctions et procedures\n",
    "\n",
    "// Initialise une date. Elle vaut alors Jeudi 01/01/1970.\n",
    "void initialiser(Date* date);\n",
    "\n",
    "// Retourne la date d'aujourd'hui\n",
    "Date date_aujourd_hui();\n",
    "\n",
    "// Affiche dans stdout la date d'aujourd'hui au format d.jour/(d.mois+1)/d.annee\n",
    "void afficher_date(Date d);\n",
    "\n",
    "// Convertit la date au format time_t de time.h en une date de type Date\n",
    "void convertir_vers_date(time_t t, Date* date); \n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "____\n",
    "##### Le corps `date.c` :\n",
    "____\n",
    "\n",
    "```c\n",
    "/**\n",
    " *  Module date\n",
    " */\n",
    "\n",
    "// Inclure l'interface Date.h\n",
    "#include \"date.h\"\n",
    "\n",
    "// Inclure les bibliothèques uniquement nécessaire à Date.c \n",
    "#include <stdio.h>\n",
    "#include <math.h>\n",
    "\n",
    "void initialiser(Date *date){\n",
    "    date->jour = 1;\n",
    "    date->nomJour = JEUDI;\n",
    "    date->mois = JAN;\n",
    "    date->annee = 1970;\n",
    "}\n",
    "void convertir_vers_date(time_t t, Date* date){\n",
    "    struct tm now;\n",
    "    localtime_r(&t, &now);//convertion fuseau horaire\n",
    "    date->jour = now.tm_mday;//jour\n",
    "    date->nomJour = now.tm_wday;//jour de la semaine \n",
    "    date->mois = now.tm_mon;//mois\n",
    "    date->annee = now.tm_year+1900;//annee (a partir de 1900) \n",
    "}\n",
    "Date date_aujourd_hui(){\n",
    "    time_t t = time(0);   // date systeme avec #include <time.h>\n",
    "    Date auj;\n",
    "    convertir_vers_date(t, &auj);\n",
    "    return auj;\n",
    "}\n",
    "void afficher_date(Date d){\n",
    "    printf(\"Date %i/%i/%i \\n\",d.jour, (d.mois+1), d.annee);\n",
    "}\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.4 Compiler un module.\n",
    "\n",
    "On peut compiler un module une fois l'interface et le corps définis avec l'option `-c `:  \n",
    ">>```c99 -Wextra -pedantic -c date.c```\n",
    "\n",
    "Dans cette étape, les commandes pré-processeur (`#define`, `#include`, etc) sont réalisées, puis le compilateur vérifie la correction syntaxique du fichier et __génère un binaire (non-exécutable)__ appelé `date.o`\n",
    "\n",
    "> __Exercice__  \n",
    "- Compiler, dans le répertoire SVN, le module `date` déjà présent. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.5 Comment utiliser un module ?\n",
    "\n",
    "On l'inclut dans l'application voulue à l'aide de la commande pré-processeur :  \n",
    "`#include \"nom module.h\"`\n",
    "\n",
    "Voici un exemple d'utilisation du module `date` dans une application `ephemeride.c` qui affiche la date du jour : \n",
    "\n",
    "```c\n",
    "#include \"date.h\"\t//Inclure le module date\n",
    "int main(){\n",
    "\tDate auj = date_aujourd_hui();\n",
    "\tafficher_date(auj);\n",
    "}\n",
    "```\n",
    "\n",
    "Il est possible de compiler ce fichier `ephemeride.c` sans générer d'exécutable. Comme pour un module, on génère un fichier binaire `ephemeride.o` avec la commande :  \n",
    ">`c99 -Wextra -pedantic -c ephemeride.c` \n",
    "\n",
    "Le fichier `executable.o` n'est pas un exécutable car il lui manque la définition des sous-programmes du module `date`. \n",
    "\n",
    "> __Exercice__  \n",
    "- Compiler, dans le répertoire SVN, le programme `ephemeride.c` déjà présent pour obtenir `ephemeride.o`.  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.6 Compilation d'une application modulaire\n",
    "\n",
    "Pour générer un fichier exécutable, il faut lier les fichiers `.o` entre eux pour créer l'exécutable final. C'est la phase __d'édition de liens__.  \n",
    "Pour cela il faut:\n",
    "- Ne pas mettre l'option `-c`\n",
    "- Lister l'ensemble des fichiers `.o`\n",
    "- Qu'il n'y ait qu'une unique fonction `main()` dans tous les fichiers objet `.o`\n",
    "- Donner le nom de l'exécutable après l'option `-o` (à défaut, `a.out` est créé)\n",
    "\n",
    "La ligne de commande suivante génère l'exécutable `main`:\n",
    "> c99  date.o ephemeride.o -o main\n",
    "\n",
    "#### Exemple de compilation séparée\n",
    "Voici un exemple de __compilation séparée__ de tous les fichiers, avec création des fichiers objet d'abord, puis l'édition de liens à la fin : \n",
    "\n",
    "```\n",
    "\tc99 -Wextra -pedantic -c  date.c \n",
    "\tc99 -Wextra -pedantic -c  ephemeride.c\n",
    "\tc99  date.o ephemeride.o -o main \n",
    "```\n",
    "> __Exercice__  \n",
    "- Créer le fichier exécutable dénommé `ephemeride` dans le répertoire SVN. L'exécuter.\n",
    "\n",
    "#### Exemple de compilation directe\n",
    "Il est possible de réaliser toutes ces étapes en utilisant une seule ligne de commande.  \n",
    "Dans ce cas, le compilateur réalise automatiquement les étapes de compilation et d'édition de liens. \n",
    "\n",
    "Pour cela, il faut lister l'ensemble des fichiers `.c` comme dans l'exemple suivant : \n",
    "\n",
    "```\n",
    "\tc99  date.c ephemeride.c -o main \n",
    "```\n",
    "> __Exercice__  \n",
    "- Dans le répertoire SVN, supprimer les fichiers objet `date.o` et `ephemeride.o`, ainsi que l'exécutable `ephemeride`. \n",
    "- Réaliser la compilation directe pour engendrer `ephemeride`\n",
    "- Observer les fichiers créés. Qu'en déduire ? \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.7 Inclusion multiple d'un même module\n",
    "\n",
    "\n",
    "Supposons que l'on souhaite développer une application `EDT` qui permette de gérer un emploi du temps pour une école. Cette application va définir  un ensemble de modules pour réprésenter les ressources à gérer : \n",
    "- les enseignants, \n",
    "- les salles, \n",
    "- les élèves, \n",
    "- les cours, \n",
    "etc..\n",
    "\n",
    "Supposons également que les modules `enseignant` et `salle` aient besoin de manipuler des dates, et donc d'inclure le module `date` dans leur en-tête.  \n",
    "Pour définir un module `cours`, on a besoin d'inclure les modules `enseignant` et `salle`.  \n",
    "On se retrouve alors dans la situation suivante : \n",
    "- `enseignant.h` inclut `date.h`\n",
    "- `salle.h` inclut `date.h`\n",
    "- `cours.h` inclut `enseignant.h` et `salle.h`. \n",
    "\n",
    "> __ Inclusions multiples __   \n",
    "> Les inclusions du pré-processeur ne sont que des 'copier/coller' des fichiers en lieu et place de la commande `#include`.   \n",
    "> Le pré-processeur fournit ainsi au compilateur un fichier unique `cours.cpp` qui comporte l'inclusion de `enseignant.h` et `salle.h`, qui eux-même incluent `cours.h`.  \n",
    "On retrouve donc __deux inclusions de `cours.h`__.\n",
    "\n",
    "Or, __le langage C interdit la déclaration multiple de variables, types ou sous-programmes de même nom.__  \n",
    "Ainsi, le compilateur vérifie dans `cours.cpp` qu'il n'existe pas deux identificateurs ou plus qui soient identiques.\n",
    "\n",
    "> __!!! Problème !!! : Le compilateur ici refuse de compiler le module `cours`__   \n",
    "car il annonce la double définition du type struct date, et des sous-programmes de `date.h`. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.8 Solution : la garde conditionnelle\n",
    "Pour résoudre ce problème, on doit rajouter à l'interface __la garde conditionnelle__ avec les commandes pré-processeur suivantes :\n",
    "\n",
    "```c\n",
    "    #ifndef DATE__H  // Garde conditionnelle : si la variable DATE__H n'existe pas \n",
    "    #define DATE__H  // La déclarer.\n",
    "    \n",
    "    /**\n",
    "     *  module date\n",
    "     */\n",
    "\n",
    "    // Inclusion des bibliothèques nécessaires à l'interface __ET__ au corps\n",
    "    #include <time.h>\n",
    "\n",
    "    // Declaration des types \n",
    "    enum NomJour { DIMANCHE, LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI};\n",
    "    enum Mois {JAN, FEV, MAR, AVR, MAI, JUIN, JUIL, AOUT, SEPT, OCT, NOV, DEC };\n",
    "    \n",
    "    ..... \n",
    "    \n",
    "    .....\n",
    "    \n",
    "    #endif // on clot la garde conditionne à la toute fin du fichier date.h\n",
    "```\n",
    "\n",
    "Ainsi:\n",
    "- lors de la première inclusion de `date.h`, la variable pré-processeur `DATE__H` n'existe pas, et le contenu de `date.h` est inclut. `DATE__H` est déclarée et existe pour tous les  traitements suivants du pré-processeur.\n",
    "- lors des instructions d'inclusion suivantes, la variable `DATE__H` existe déjà. Avec la close `#ifndef`, tout ce qui se trouve avant `#endif` n'est pas considéré pour l'inclusion si `DATE_H`. \n",
    "\n",
    "> __ Important__  \n",
    "Il faut TOUJOURS ajouter une garde conditionnelle à son fichier d'en-tête.\n",
    "\n",
    "__Note__ L'identificateur de la constante pré-processeur est choisi arbitrairement. Il est d'usage d'utiliser le nom du module pour garantir son unicité.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> __Exercice__  \n",
    "- Dans le répertoire SVN, compiler les fichiers `enseignant.c`, `cours.c`, `salle.c`, `date.c` et `EDT.c` afin de créer l'exécutable `EDT`.\n",
    "- Quels erreurs de double inclusion observez-vous ? \n",
    "- Corriger les fichiers d'en-tête qui en sont responsables."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.9 Visibilité des variables en C\n",
    "\n",
    "Par défaut, tous les sous-programmes et variables globales définies dans __le corps `module.c` sont visibles__ par les modules et programmes qui l'incluent.\n",
    "\n",
    "> Il faut _explicitement_ rendre une variable ou fonction locale au module.\n",
    "\n",
    "#### La propriété `static`\n",
    "\n",
    "Pour fournir une visibilité locale à une variable ou à un sous-programme, il faut précéder sa déclaration avec le mot-clé `static`.\n",
    "> __Attention__ : on ne peut pas rendre un type static\n",
    "\n",
    "#### Exemple\n",
    "\n",
    "---\n",
    "Voici l'interface `exemple_static.h` du module `exemple_static` :\n",
    "\n",
    "---\n",
    "\n",
    "```c\n",
    "#ifndef EXEMPLE_STATIC__H\n",
    "#define EXEMPLE_STATIC__H\n",
    "\n",
    "// Unique fonction\n",
    "// visible par\n",
    "// les autres modules\n",
    "int f();\n",
    "\n",
    "#endif\n",
    "```\n",
    "\n",
    "-----\n",
    "\n",
    "Et voici le corps `exemple_static.c` \n",
    "\n",
    "-----\n",
    "```c\n",
    "#include \"exemple_static.h\"\n",
    "// fonction locale au module Static\n",
    "// non visible des autres modules.\n",
    "static int max(int a, int b) {\n",
    "  if (a > b) {\n",
    "    return a;\n",
    "  } else {\n",
    "    return b;\n",
    "  }\n",
    "}\n",
    "// fonction f() presente dans le .h,\n",
    "// visible par les autres modules\n",
    "int f(){\n",
    "  int val1 = 2;\n",
    "  int val2 = 8;\n",
    "  return max(val1, val2);\n",
    "}\n",
    "```\n",
    "\n",
    "---\n",
    "La fonction `max` est ici `static`, et donc uniquement visible des sous-programmes du corps du module. \n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Cas d'utilisation de `static`\n",
    "\n",
    "Voici quelques cas d'utilisation (non exhaustifs) :\n",
    "- Pour définir une fonction, localement au module, qui présente le même identificateur qu'une fonction déjà présente dans un des modules inclus dans l'interface.  \n",
    "Typiquement, si on souhaite définir sa propre fonction `max` alors qu'on a inclut `math.h` dans l'interface.\n",
    "- Pour définir une variable, à portée globale pour le module, mais que l'on ne veut pas visible du reste de l'application. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> __Exercice__  \n",
    "- Dans le répertoire SVN, rendre `static` le sous-programme `afficher_date` du module `date`. Compiler à nouveau l'application `ephemeride`.  \n",
    "Observer que ce sous-programme n'est plus visible."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.10 Externaliser une variable du module \n",
    "\n",
    "Il est possible de déclarer une variable globale au module, et de la rendre utilisable par le reste de l'application.  \n",
    "Cette variable globale est visible et modifiable par tous les sous-programmes appartenant aux modules et au programme principal qui incluent ce module.\n",
    "\n",
    "On prendra l'exemple d'un module `compteur` qui présente une variable globale `compteur`, que l'on souhaite consulter, incrémenter ou ré-initialiser par les modules qui incluent `module.h`.  \n",
    "Dans l'exemple suivant, `compteur.h` offre des sous-programmes qui permettent de maniputer ce `compteur`.\n",
    "\n",
    "---\n",
    "Voici l'interface du module `compteur.h` qui spécifie les sous-programmes permettant de manipuler une variable `compteur`. \n",
    "\n",
    "--- \n",
    "\n",
    "```c\n",
    "#ifndef _COMPTEUR_H\n",
    "#define _COMPTEUR_H\n",
    "\n",
    "// Specification de la procédure re-initialiser\n",
    "void re_initialiser();\n",
    "// Specification de la procedure incrementer\n",
    "void incrementer();\n",
    "// Specification de la function valeur\n",
    "int valeur();\n",
    "\n",
    "#endif \n",
    "```\n",
    "\n",
    "--- \n",
    "Voici le corps `compteur.c`.  \n",
    "Pour ne pas exposer la variable `compteur` directement, on ne la déclare pas dans l'interface, mais dans le corps du module. \n",
    ">__Attention__\n",
    "> - il faut obligatoirement l'initialiser au moment de sa déclaration. \n",
    "> - il ne faut pas la rendre `static` !\n",
    "\n",
    "---\n",
    "\n",
    "```c\n",
    "#include <stdio.h>\n",
    "\n",
    "// declaration de la variable globale + initialisation à 0. \n",
    "int compteur = 0;\n",
    "\n",
    "void re_initialiser() {\n",
    "\tcompteur=0;\n",
    "}\n",
    "void incrementer() {\n",
    "\tcompteur++;\n",
    "}\n",
    "int valeur() {\n",
    "\treturn compteur;\n",
    "}\n",
    "```\n",
    "\n",
    "--- \n",
    "Voici un programme de test du compteur `test_compteur.c`.  \n",
    "Pour obtenir d'accès à la variable globale `compteur`, et donc pouvoir utiliser les sous-programmes du module compteur pour la manipuler, il faut :\n",
    "- Déclarer à nouveau `int compteur` dans le programme de test\n",
    "- Dans la déclaration, __utiliser le mot-clé `extern`__.  \n",
    "Le compilateur sait alors que cette variable existe dans un autre module. \n",
    "\n",
    "---\n",
    "```c\n",
    "#include \"compteur.h\"\n",
    "#include <stdio.h>\n",
    "\n",
    "// acces au compteur de compteur.c\n",
    "extern int compteur;\n",
    "\n",
    "int main(){\n",
    "  // initialiser\n",
    "  re_initialiser();\n",
    "  printf(\"Init Compteur c=%d\\n\", valeur());\n",
    "  // incrementer\n",
    "  incrementer();\n",
    "  printf(\"Incrementer c=%d\\n\", valeur());\n",
    "  // access au compteur sans appel a valeur()\n",
    "  incrementer();\n",
    "  incrementer();\n",
    "  printf(\"Acces direct a compteur c=%d\\n\", compteur);\n",
    "\n",
    "  return 0; \n",
    "}\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> __Exercice__  \n",
    "- Dans le répertoire SVN, compiler le fichier `test_compteur.c`. Observer que le compteur s'incrémente bien. \n",
    "- Dé-commenter les deux instructions qui se trouvent entre les commentaires `// *** DECOMMENTER ***` et `//**** FIN DECOMMENTER ***`.  \n",
    "Qu'observez-vous ? Que peut-on en conclure sur la possibilité d'encapsuler complètement une variable externalisée ?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.10 Exercice - UNO\n",
    "\n",
    "La correction des exercices 2 et 3 qui ont été traités au TP1 est disponible sous SVN, dans le répertoire `c2/tp2/UNO`.  \n",
    "__Sans créer de nouveaux sous-programmes__, il est demandé dans ce travail de réorganiser le code des ces deux fichiers `.c` pour en extraire des modules.  \n",
    "Pour cela, on vous demande de : \n",
    "\n",
    "- Créer 4 modules (`carte`, `main`, `jeu` et `UNO`) ;\n",
    "- Produire les exécutables `tester_UNO` et `jouer_UNO`. \n",
    "\n",
    "L'exécutable `jouer_UNO` permet de lancer le jeu de UNO. Il n'est pas complet car l'ensemble des sous-programmes nécessaires au jeu n'est pas disponible. Dans les faits, il ne fera que préparer le jeu. \n",
    "\n",
    "_Attention à la garde conditionnelle !_\n",
    "\n",
    "Pour rendre ce travail, vous ajouterez vos fichiers au répertoire UNO avec la commande `svn add`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "---\n",
    "---"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Format de la Cellule Texte Brut",
  "kernelspec": {
   "display_name": "C",
   "language": "c",
   "name": "c"
  },
  "language_info": {
   "file_extension": ".c",
   "mimetype": "text/plain",
   "name": "c"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
